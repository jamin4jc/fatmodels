<!DOCTYPE html>

<!--
  Google HTML5 slide template

  Authors: Luke Mahé (code)
           Marcin Wichary (code and design)

           Dominic Mazzoni (browser compatibility)
           Charles Chen (ChromeVox support)

  URL: http://code.google.com/p/html5slides/
-->

<html>
  <head>
    <title>Keynote and Active Record</title>

    <meta charset='utf-8'>
    <script
      src='http://html5slides.googlecode.com/svn/trunk/slides.js'></script>
  </head>

  <style>
    /* Your individual styles here, or just use inline styles if that’s
       what you want. */
    .slides > article:not(.nobackground):not(.biglogo) {
      background-image: url(../images/nw_logo_small.jpg) !important;
      background-position: 810px 610px !important;
    }

    article.smaller p,
    article.smaller ul,
    article.smaller ol,
    article.smaller dl { font-size: 20px; line-height: 24px; letter-spacing: 0; }

    article dt { margin-top:1em; }
  </style>

  <body style='display: none'>

    <section class='slides layout-regular template-default'>

      <!-- Your slides (<article>s) go here. Delete or comment out the
           slides below. -->



      <!--<article class='biglogo'>
      </article>-->

      <article>
        <h1 style="font-size:55px">
          Lean &amp; Mean Domain Objects
        </h1>
        <h3><strike>despite</strike> with Active Record</h3>
        <p>
          Todd Kaufman
          <br>
          Jason Karns
          <br>
          <br>
          January 8, 2013
        </p>
      </article>

      <!--
      <article>
        <h3>active record</h3>
        <p>active record (lowercase) is an ORM pattern.</p>
        <ul>
          <li>database tables map to objects</li>
          <li>table columns map to object attributes/properties</li>
          <li>objects relate to each other via associations (<var>has_many</var>, <var>belongs_to</var>, <var>has_one</var>) using the table's foreign_keys</li>
        </ul>
      </article>

      <article>
        <h3>Active Record in Ruby</h3>
        <p>Active Record, the ruby framework, is an implementation of the active record pattern in Ruby</p>
        <ul>
          <li>Active Record is driven by convention over configuration</li>
        </ul>
      </article>
      -->

      <article>
        <h1>Agenda</h1>
        <ol>
          <li>Value Objects</li>
          <li>Advanced Scopes</li>
          <li>Query Objects</li>
          <li>Service Objects</li>
          <li>Tips &amp; Tricks (Convention <em>by</em> Configuration!)</li>
      </article>

      <article>
        <h2>Convention by Configuration!</h2>
      </article>

      <article>
        <h3>Table names to Class names</h3>
        <dl>
          <dt>Convention</dt>
          <dd>class names =&gt; singular, CamelCased</dd>
          <dd>table names =&gt; plural, snake_cased</dd>
          <dt>Override</dt>
          <dd><pre><code>class MyClass &lt; ActiveRecord::Base
  set_table_name :table_of_my_classes
  ...
end
</code></pre></dd>
          <dt>Custom Convention</dt>
          <dd>see <code>ActiveSupport::Inflector::Inflections</code></dd>
        </dl>
      </article>

      <article>
        <h3>Primary Key</h3>
        <dl>
          <dt>Convention</dt>
          <dd>column name: <code>id</code></dd>
          <dt>Override</dt>
          <dd><pre><code>class MyClass &lt; ActiveRecord::Base
  set_primary_key :seq_id
  ...
end
</code></pre></dd>
          <dt>Custom Convention</dt>
          <dd><pre><code>class ActiveRecord::Base
  def self.get_primary_key(classname)
    "seq_id"
  end
end
</code></pre></dd>
        </dl>
      </article>

      <article>
        <h3>Primary Key: Composite Key</h3>
        <p><code>gem install composite_primary_keys</code></p>
        <pre><code>class Person &lt; ActiveRecord::Base
  set_primary_keys :first_name, :last_name
end
</code></pre>
      </article>

      <article>
        <h3>Foreign Keys: Composite Key</h3>
        <p>foreign key must define <em>all</em> columns of the composite key and they must be <em>in order</em></p>
<pre><code>class Person &lt; ActiveRecord::Base
  set_primary_keys :first_name, :last_name
  has_many :cars, :foreign_key =&gt; [:first_name, :last_name]
  ...
end

class Car &lt; ActiveRecord::Base
  belongs_to :person, :foreign_key =&gt; [:first_name, :last_name]
  ...
end</code></pre>
      </article>

      <article>
        <h3>Foreign Key Irregulars</h3>
        <p>abbreviation only used as foreign keys? <br/>(main class isn't abbreviated)</p>
        <br/>
        <pre><code>class Conference &lt; ActiveRecord
  has_many :speakers, :foreign_key =&gt; :conf_id
  has_many :attendees, :foreign_key =&gt; :conf_id
  # this could go on for a while ...
end

class Speaker &lt; ActiveRecord::Base
  belongs_to :conference, :foreign_key =&gt; :conf_id
end

class Attendee &lt; ActiveRecord::Base
  belongs_to :conference, :foreign_key =&gt; :conf_id
end</code></pre>
      </article>

      <article>
        <pre><code># config/initializers/inflections.rb
ActiveSupport::Inflector.inflections do |inflect|
  inflect.foreign_key :conference =&gt; :conf_id # requires a monkey-patch
end
</code></pre>
        <pre><code>class Conference &lt; ActiveRecord::Base
  has_many :speakers
  has_many :attendees
  # this could go on for a while ...
end

class Speaker &lt; ActiveRecord::Base
  belongs_to :conference
end

class Attendee &lt; ActiveRecord::Base
  belongs_to :conference
end</code></pre>
      </article>

      <article>
        <h3>Foreign Key Irregulars: How? Monkey-Patch!</h3>
        <pre><code>class ActiveSupport::Inflector::Inflections
  attr_reader :foreign_keys

  def foreign_keys
    @foreign_keys ||= {}
  end

  def foreign_key(association_name_to_column_name)
    association_name_to_column_name.each do |association_name, column_name|
      foreign_keys[association_name.to_s] = column_name.to_s
    end
  end
end
</code></pre>
      </article>

      <article>
        <h3>Redundant Domain Prefixes? Alias!</h3>
      </article>

      <article class='fill build'>
        <div>
          <h3>Trouble with <em>belongs_to</em> versus <em>has_one</em>, <em>has_many</em>?</h3>
          <p>
            <img src='images/toystory.jpg'/>
          </p>
        </div>
      </article>

      <article>
        <h3>Defining Scopes</h3>
        <ul>
          <li>defined with a string
            <pre><code>scope :trust_effective_date_established, where("trust_effective_date is not null")</code></pre>
          </li>
          <li>defined with a hash
<pre><code>scope :trust_effective_date_not_established, where(:trust_effective_date =&gt; nil)
scope :is_waive_override, where(:waive_override =&gt; 'Y')</code></pre>
          </li>
          <li>defined with a heredoc string (bonus: RubyMine colorizes heredoc strings according to heredoc delimiters)
            <pre><code>scope :flexible_advantage, where(&lt;&lt;-SQL)
  seq_id in (SELECT case_seq_id
             FROM ppak_contracts
             WHERE prod_code in ('C3', 'T3'))
SQL</code></pre>
          </li>
        </ul>
      </article>

      <article>
        <h3>Advanced Scopes</h3>
        <ul>
          <li>can take parameters
<pre><code>scope :for_participant, lambda { |partic| {:where =&gt; "partic_seq_id = #{partic}"} }
# usage
model_selections_for_john = IK::PpakParticModelSelection.for_participant(1357924680)</code></pre>
          </li>
          <li>can be defined with pseudo-prepared SQL statements
            <pre><code>scope :active_as_of, lambda { |asof_date| where("record_start_datetime &lt;= ?", asof_date) }</code></pre>
          </li>
          <li>can build upon other scopes
            <pre><code>scope :active, lambda { active_as_of(IK::PpakDateCard.first.daily_cycle_to_date) }</code></pre>
          </li>
        </article>

    </section>

  </body>
</html>
