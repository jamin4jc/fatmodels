<!DOCTYPE html>

<!--
  Google HTML5 slide template

  Authors: Luke Mahé (code)
           Marcin Wichary (code and design)

           Dominic Mazzoni (browser compatibility)
           Charles Chen (ChromeVox support)

  URL: http://code.google.com/p/html5slides/
-->

<html>
  <head>
    <title>Keynote and Active Record</title>

    <meta charset='utf-8'>
    <script
      src='http://html5slides.googlecode.com/svn/trunk/slides.js'></script>
  </head>

  <style>
    /* Your individual styles here, or just use inline styles if that’s
       what you want. */
    .slides > article:not(.nobackground):not(.biglogo) {
      background-image: url(../images/nw_logo_small.jpg) !important;
      background-position: 810px 610px !important;
    }

    article.smaller p,
    article.smaller ul,
    article.smaller ol,
    article.smaller dl { font-size: 20px; line-height: 24px; letter-spacing: 0; }

    article dt { margin-top:1em; }
  </style>

  <body style='display: none'>

    <section class='slides layout-regular template-default'>

      <!-- Your slides (<article>s) go here. Delete or comment out the
           slides below. -->


      <!--<article class='biglogo'>
      </article>-->

      <article class='smaller'>
        <h3>Scopes Gone Wrong</h3>
        <ul>
          <li>Scopes can sometimes get a little unwieldy
<pre><code>  scope :for_rate_contracts, lambda { |rate_contracts|
    rate_contracts = Array.wrap(rate_contracts)

    unless rate_contracts.empty?
      device_conditions = Device.scoped.arel.constraints.inject do |query, clause|
        query.and(clause)
      end
      joins(:device).
      joins('LEFT OUTER JOIN rate_addresses AS ras ON (devices.rate_address_id = ras.id)').
      joins('LEFT OUTER JOIN rate_contract_devices AS rcds ON (rcds.device_id = devices.id)').
      where('(position = 1 AND ras.end_point_1_contract_id IN (:rate_contract_ids)) OR ' +
            '(position = 2 AND ras.end_point_2_contract_id IN (:rate_contract_ids)) OR ' +
            '(position = 3 AND ras.end_point_3_contract_id IN (:rate_contract_ids)) OR ' +
            '(position = 4 AND ras.end_point_4_contract_id IN (:rate_contract_ids)) OR ' +
            '(rcds.indirect_control_rate_contract_id IN (:rate_contract_ids))',
            :rate_contract_ids => rate_contracts.map(&:id)).
      where(device_conditions)
    else
      #with no rate contracts always return none
      where("1 = 0")
    end
  }
</code></pre>
          </li>
        </ul>
      </article>

      <article class='smaller'>
        <h3>Resulting In</h3>
        <ul>
          <li>Really freaking big AR models</li>
          <li>Especially when your system has <i>God Objects</i></li>
          <li>Big Objects leads to big and difficult specs</li>
          <li>Usually lacking in test coverage</li>
          <li>Leading to some difficult to find bugs</li>
        </ul>
      </article>

      <article class='smaller'>
        <h3>Rails Scope Cleverness also Confuses</h3>
        <ul>
          <li>Default Scopes Kill Kittens!
            <pre><code>
              default_scope :conditions => {:deactivated_at => nil}
            </code></pre>
          </li>
          <li>Please don't use...</li>
        </ul>
      </article>

      <article class='smaller'>
        <h3>Time to ask yourself, What Would Martin Fowler Do?</h3>
        <ul>
          <li>Extract Class when:</li>
          <li>You have one class doing work that should be done by two.</li>
          <li>Query objects to the rescue!</li>
        </ul>
      </article>

      <article class='smaller'>
        <h2>Exercise</h2>
        <h3>Simple Scope Extraction</h3>
        <ul>
          <li>Extract Scopes in the Speaker model into Query objects</li>
          <li>Characterize with tests if they aren't already</li>
        </ul>
      </article>

      <article class='smaller'>
        <h2>Exercise</h2>
        <h3>Advanced Scope Extraction</h3>
        <ul>
          <li>Build a Query for positive feedback (3 or higher)</li>
          <li>It should work with both Conferences and Presentations</li>
        </ul>
      </article>

      <article class='smaller'>
        <h3>Gripes</h3>
        <ul>
          <li>Scopes can be chained</li>
          <li>I like calling Speaker.accepted</li>
        </ul>
      </article>

      <article class='smaller'>
        <h3>Pros</h3>
        <ul>
          <li>Isolates complex query logic</li>
          <li>Easier to test</li>
          <li>Easier to mock in other tests</li>
          <li>Allows mixing of Enumerable methods with SQL</li>
          <li>Can be referenced from model to look just like scopes</li>
        </ul>
      </article>

      <article class='smaller'>
        <h3>Cons</h3>
        <ul>
          <li>Probably more complex than what they are worth for simple scopes</li>
        </ul>
      </article>

      <article class='smaller'>
        <h3>AR Callbacks</h3>
        <ul>
          <li>Easy to use lifecycle hooks</li>
          <li>Easy to use often == widely misused</li>
        </ul>
      </article>

      <article class='smaller'>
        <h3>Lifecycle Hooks</h3>
        <ul>
          <li>Quick, list the Create lifecycle hooks in order</li>
          <li>The first is <b>before_validation</b></li>
        </ul>
      </article>

      <article class='smaller'>
        <h3>From guides.rubyonrails.org: </h3>
        <ul>
          <li>before_validation</li>
          <li>after_validation</li>
          <li>before_save</li>
          <li>around_save</li>
          <li>before_create</li>
          <li>around_create</li>
          <li>after_create</li>
          <li>after_save</li>
        </ul>
      </article>

      <article class='smaller'>
        <h3>From logicalfriday.com</h3>
        <pre><code>
class User < ActiveRecord::Base

  after_save :queue_welcome_email, :on => :create

  private

  def queue_welcome_email
    Resque.enqueue(WelcomeEmailJob, self.id)
  end

end
</code></pre>
      </article>

      <article class='smaller'>
        <h3>Why does this result in the occassional ActiveRecord::RecordNotFound exception</h3>
      </article>

      <article class='smaller'>
        <h3>Whoops</h3>
        <ul>
          <li>The rails guide is incorrect.</li>
          <li>after_commit is also a hook, executed after after_save</li>
          <li>Use it instead of after_save if you are seeing things like message being enqueued before the db has the record</li>
        </ul>
      </article>

      <article class='smaller'>
        <h3>Other Gotchas</h3>
        <ul>
          <li>When multiple callbacks on a file, ordering is important
            <pre><code>
before_validation :setup_c_and_i_data, :unless => :recurring?, :on => :create
after_create :update_selected_control_strategies
after_create :create_triggers, :unless => :template?
after_commit :send_create_email, :unless => Proc.new { | ce | ce.template? || ce.recurring? }, :on => :create
            </code></pre>
          </li>
          <li>Not all methods on a model provided by AR trigger callbacks (update_all for example)
            <pre><code>
 User.where(:id=>@user.id).update_all(:credits => @user.credits+5)
            </code></pre>
          </li>
        </ul>
      </article>

      <article class='smaller'>
        <h3>Maybe we should stop screwing around with half assed AOP approaches inside our already chunky AR models</h3>
      </article>

      <article class='smaller'>
        <h3>Services When the Callback is</h3>
        <ul>
          <li>interacting with other models</li>
          <li>significantly complex to warrant it's own class</li>
          <li>interfacing with an external service (web, file, mail)</li>
          <li>doing something totally tangent to the responsibility of the model
            <pre><code>
class UserAuthenticator
  def initialize(user)
    @user = user
  end

  def authenticate(unencrypted_password)
    return false unless @user

    if BCrypt::Password.new(@user.password_digest) == unencrypted_password
      @user
    else
      false
    end
  end
end
            </code></pre>
          </li>
        </ul>
      </article>

      <article class='smaller'>
        <h3>Observers when the Callback is</h3>
        <ul>
          <li>the same across different models</li>
          <li>simple but in an already bloated class
            <pre><code>
class UserObserver < ActiveRecord::Observer
  def after_create(model)
    # code to send confirmation email...
  end
end
            </code></pre>
          </li>
        </ul>
      </article>

      <article class='smaller'>
        <h2>Exercise</h2>
        <h3>Clean up the abstract acceptance conversion into a presentation acceptance service</h3>
        <ul>
          <li>Leverage existing tests or characterize before hand</li>
          <li>Assume this would be called directly by a controller (or spec in our case)</li>
        </ul>
      </article>

      <article class='smaller'>
        <h3>Service Pros</h3>
        <ul>
          <li>Clear division of responsibility for complex actions</li>
          <li>Much easier to test in isolation and make use of test doubles</li>
          <li>Can become a more appropriate home for responsibilities that aren't specific to a model</li>
          <li>Can't be subverted with tricky AR calls</li>
        </ul>
        <h3>Service Cons</h3>
        <ul>
          <li>Can also become a dumping ground for code, easy to bloat</li>
          <li>Controller may have to call off to numerous actions to get things done</li>
        </ul>
      </article>

      <article class='smaller'>
        <h2>Exercise</h2>
        <h3>New requirement, we must email whenever speaker info OR abstract info is submitted</h3>
        <ul>
          <li>Leverage Active Record Observer</li>
        </ul>
      </article>

      <article class='smaller'>
        <h3>Observer Pros</h3>
        <ul>
          <li>Easy to consolidate cross domain model logic</li>
          <li>Wiring into Rails apps is very straightforward
            <pre><code>
config.active_record.observers = :user_observer
            </code></pre>
          </li>
        </ul>
        <h3>Observer Cons</h3>
        <ul>
          <li>Can be somewhat difficult to test</li>
          <li>Can still be subverted with tricky AR calls</li>
        </ul>
      </article>

    </section>

  </body>
</html>
